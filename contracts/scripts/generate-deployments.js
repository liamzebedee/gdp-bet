#!/usr/bin/env node

// Generate deployments.js file for frontend from Foundry artifacts
// Usage: node scripts/generate-deployments.js [network] [broadcast-file]

const fs = require('fs');
const path = require('path');

function generateDeployments(network = 'sepolia', broadcastFile) {
  const networkId = network === 'sepolia' ? '11155111' : '31337';
  
  if (!broadcastFile) {
    broadcastFile = `broadcast/DeploySepoliaWithPools.s.sol/${networkId}/run-latest.json`;
  }

  if (!fs.existsSync(broadcastFile)) {
    console.error(`âŒ Broadcast file not found: ${broadcastFile}`);
    process.exit(1);
  }

  console.log(`ðŸ“„ Reading deployment data from ${broadcastFile}`);
  const broadcastData = JSON.parse(fs.readFileSync(broadcastFile, 'utf8'));

  // Helper to read ABI from forge out directory
  function readABI(contractName) {
    const abiPath = `out/${contractName}.sol/${contractName}.json`;
    if (fs.existsSync(abiPath)) {
      const artifact = JSON.parse(fs.readFileSync(abiPath, 'utf8'));
      return artifact.abi;
    }
    console.warn(`âš ï¸  ABI not found for ${contractName}`);
    return [];
  }

  // Extract contract addresses
  const contracts = {};
  const deployedContracts = broadcastData.transactions.filter(tx => tx.contractAddress);
  
  for (const tx of deployedContracts) {
    if (tx.contractName) {
      contracts[tx.contractName] = {
        address: tx.contractAddress,
        abi: readABI(tx.contractName)
      };
    }
  }

  // Handle token contracts deployed by GDPMarket
  if (contracts.GDPMarket) {
    // We'll need to get these addresses from the market contract calls
    // For now, we'll leave placeholders that can be filled by the deployment script
    contracts.LongToken = {
      address: "LONG_TOKEN_ADDRESS", // To be replaced by deployment script
      abi: readABI('LongToken')
    };
    contracts.ShortToken = {
      address: "SHORT_TOKEN_ADDRESS", // To be replaced by deployment script  
      abi: readABI('ShortToken')
    };
  }

  // Generate deployments object
  const deployments = {
    chainId: parseInt(networkId),
    name: network.charAt(0).toUpperCase() + network.slice(1),
    rpcUrl: network === 'sepolia' ? 'https://rpc.sepolia.org' : 'http://localhost:8546',
    contracts,
    pools: {
      longUSDC: "LONG_POOL_ADDRESS", // To be filled by deployment script
      shortUSDC: "SHORT_POOL_ADDRESS" // To be filled by deployment script  
    },
    parameters: {
      openAt: "OPEN_AT_TIMESTAMP",
      closeAt: "CLOSE_AT_TIMESTAMP", 
      kPpm: "K_PPM_VALUE",
      mintFeeBps: "MINT_FEE_BPS_VALUE",
      pairRedeemFeeBps: "PAIR_REDEEM_FEE_BPS_VALUE",
      settleSkimBps: "SETTLE_SKIM_BPS_VALUE"
    },
    deployedAt: new Date().toISOString()
  };

  // Write to frontend directory
  const frontendPath = '../frontend';
  if (!fs.existsSync(frontendPath)) {
    fs.mkdirSync(frontendPath, { recursive: true });
  }

  const outputPath = path.join(frontendPath, 'deployments.js');
  const jsContent = `// Auto-generated deployment addresses for ${deployments.name}
// Generated on ${deployments.deployedAt}
// DO NOT EDIT - This file is automatically generated

export const ${network.toUpperCase()}_DEPLOYMENTS = ${JSON.stringify(deployments, null, 2)};

export default ${network.toUpperCase()}_DEPLOYMENTS;
`;

  fs.writeFileSync(outputPath, jsContent);
  console.log(`âœ… Generated ${outputPath}`);

  // Also create a TypeScript version
  const tsOutputPath = path.join(frontendPath, 'deployments.ts');
  const tsContent = `// Auto-generated deployment addresses for ${deployments.name}
// Generated on ${deployments.deployedAt}
// DO NOT EDIT - This file is automatically generated

export interface ContractDeployment {
  address: string;
  abi: any[];
}

export interface DeploymentConfig {
  chainId: number;
  name: string;
  rpcUrl: string;
  contracts: Record<string, ContractDeployment>;
  pools: {
    longUSDC: string;
    shortUSDC: string;
  };
  parameters: {
    openAt: string | number;
    closeAt: string | number;
    kPpm: string | number;
    mintFeeBps: string | number;
    pairRedeemFeeBps: string | number;
    settleSkimBps: string | number;
  };
  deployedAt: string;
}

export const ${network.toUpperCase()}_DEPLOYMENTS: DeploymentConfig = ${JSON.stringify(deployments, null, 2)};

export default ${network.toUpperCase()}_DEPLOYMENTS;
`;

  fs.writeFileSync(tsOutputPath, tsContent);
  console.log(`âœ… Generated ${tsOutputPath}`);

  return deployments;
}

// Run if called directly
if (require.main === module) {
  const network = process.argv[2] || 'sepolia';
  const broadcastFile = process.argv[3];
  generateDeployments(network, broadcastFile);
}

module.exports = { generateDeployments };